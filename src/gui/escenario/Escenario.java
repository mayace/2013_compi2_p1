/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package gui.escenario;

import compiler.lvl.Espacio;
import compiler.lvl.Estructura;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.image.BufferedImage;
import java.io.File;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import javax.swing.ImageIcon;

/**
 *
 * @author ce
 */
public class Escenario extends javax.swing.JPanel {

  /**
   * Creates new form Escenario
   */
  public Escenario() {
    initComponents();
  }

  /**
   * This method is called from within the constructor to initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is always
   * regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 2));
    setPreferredSize(new java.awt.Dimension(600, 600));
    addMouseListener(new java.awt.event.MouseAdapter() {
      public void mouseClicked(java.awt.event.MouseEvent evt) {
        formMouseClicked(evt);
      }
    });
    addKeyListener(new java.awt.event.KeyAdapter() {
      public void keyTyped(java.awt.event.KeyEvent evt) {
        formKeyTyped(evt);
      }
      public void keyPressed(java.awt.event.KeyEvent evt) {
        formKeyPressed(evt);
      }
    });

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
    this.setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 396, Short.MAX_VALUE)
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGap(0, 296, Short.MAX_VALUE)
    );
  }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed
      // TODO add your handling code here:
      int keyCode = evt.getKeyCode();
      final HashMap<Integer, HashSet<Hero>> km = getKeyMap();

      if (km.containsKey(keyCode)) {
        HashSet<Hero> get = keyMap.get(keyCode);
        final Estructura s = getEstructura();

        for (Hero hero : get) {
          if (keyCode == hero.keyDown) {
            Point next = hero.nextMoveDown();

            if (s.containsKey(next)) {
              Estructura.Casilla casilla = s.get(next);
              if (casilla == null || casilla.getTipo().getPasable()) {
                hero.moveDown();
                repaint();
              }

            }

          } else if (keyCode == hero.keyLeft) {

            Point next = hero.nextMoveLeft();

            if (s.containsKey(next)) {
              Estructura.Casilla casilla = s.get(next);
              if (casilla == null || casilla.getTipo().getPasable()) {
                hero.moveLeft();
                repaint();
              }
            }
          } else if (keyCode == hero.keyRight) {
            Point next = hero.nextMoveRight();

            if (s.containsKey(next)) {
              Estructura.Casilla casilla = s.get(next);
              if (casilla == null || casilla.getTipo().getPasable()) {
                hero.moveRight();
                repaint();
              }
            }
          } else if (keyCode == hero.keyUp) {
            Point next = hero.nextMoveUp();

            if (s.containsKey(next)) {
              Estructura.Casilla casilla = s.get(next);
              if (casilla == null || casilla.getTipo().getPasable()) {
                hero.moveUp();
                repaint();
              }
            }
          }

        }
      }
    }//GEN-LAST:event_formKeyPressed

    private void formKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyTyped
      // TODO add your handling code here:
    }//GEN-LAST:event_formKeyTyped

  private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked
    // TODO add your handling code here:
  }//GEN-LAST:event_formMouseClicked
  // Variables declaration - do not modify//GEN-BEGIN:variables
  // End of variables declaration//GEN-END:variables
  private Estructura estructura = null;
  private final Dimension CELL = new Dimension(0, 0);
  private final LinkedList<Hero> heroes = new LinkedList<>();
  private final LinkedList<MItem> enemies = new LinkedList<>();
  HashMap<Integer, HashSet<Hero>> keyMap = new HashMap<>();
  GItem bg = new GItem(new ImageIcon("texture/t1.png").getImage(), null);

  void addHero(Hero hero) {
    LinkedList<Hero> ll = heroes;//si es get ciclo infinot
    ll.add(hero);

    HashMap<Integer, HashSet<Hero>> km = getKeyMap();
    int[] keys = new int[]{hero.keyDown, hero.keyLeft, hero.keyRight, hero.keyUp};

    for (int k : keys) {
      if (km.containsKey(k)) {
        HashSet<Hero> get = km.get(k);
        get.add(hero);
      } else {
        HashSet<Hero> get = new HashSet<>();
        get.add(hero);
        km.put(k, get);
      }
    }

  }

  //<editor-fold defaultstate="collapsed" desc="draw">
  @Override
  public void paint(Graphics g) {
    super.paint(g);

    drawGrid(g);
    drawMap(g);
    drawHeros(g);


  }

  private void drawGrid(Graphics g) {
    Dimension tamanio = getEstructura().getTamanio();
    CELL.width = getWidth() / tamanio.width;
    CELL.height = getHeight() / tamanio.height;

    for (int i = 0; i < tamanio.width; i++) {
      final int x = CELL.width * i;
      g.drawLine(x, 0, x, getHeight());
    }
    for (int j = 0; j < tamanio.width; j++) {
      final int y = CELL.height * j;
      g.drawLine(0, y, getWidth(), y);
    }
  }

  private void drawGItem(Graphics g, GItem d) {

    final Point p = d.point;
    int x = p.x * CELL.width;
    int y = p.y * CELL.height;

    g.drawImage(d.image, x, y, CELL.width, CELL.height, this);
  }

  private void drawHeros(Graphics g) {
    LinkedList<Hero> l = getHeroes();
    for (Hero hero : l) {
      drawGItem(g, hero);
    }
  }

  private void drawMap(Graphics g) {

    final Estructura e = getEstructura();

    //bg
    for (int i = 0; i < e.getTamanio().width; i++) {
      for (int j = 0; j < e.getTamanio().height; j++) {
        GItem gi = new GItem(new ImageIcon("ext/texture/t1.png").getImage(), new Point(i, j));
        drawGItem(g, gi);
      }
    }


    //map
    for (Map.Entry<Point, Estructura.Casilla> entry : e.entrySet()) {
      Point point = entry.getKey();
      Estructura.Casilla casilla = entry.getValue();
      Image img = null;
      if (casilla != null) {
        img = new ImageIcon(casilla.getTipo().getImagen().getAbsolutePath()).getImage();
      }
      GItem gi = new GItem(img, point);
      drawGItem(g, gi);
    }
  }

  //</editor-fold>
  //<editor-fold defaultstate="collapsed" desc="classes">
  public interface Locus {

    public void moveUp();

    public void moveDown();

    public void moveLeft();

    public void moveRight();
  }

  public static class GItem {

    public Image image;
    public Point point = new Point(0, 0);

    public GItem(Image image) {
      this.image = image;
    }

    public GItem(Image image, Point point) {
      this.image = image;
      this.point = point;
    }
  }

  public static class MItem extends GItem implements Locus {

    int keyUp = KeyEvent.VK_UP;
    int keyDown = KeyEvent.VK_DOWN;
    int keyLeft = KeyEvent.VK_LEFT;
    int keyRight = KeyEvent.VK_RIGHT;

    public MItem(Image img) {
      super(img);
    }

    @Override
    public void moveUp() {
      point.y--;
    }

    @Override
    public void moveDown() {
      point.y++;
    }

    @Override
    public void moveLeft() {
      point.x--;
    }

    @Override
    public void moveRight() {
      point.x++;
    }

    public Point nextMoveDown() {
      Point next = new Point(point);
      next.y++;
      return next;
    }

    public Point nextMoveLeft() {
      Point next = new Point(point);
      next.x--;
      return next;
    }

    public Point nextMoveRight() {
      Point next = new Point(point);
      next.x++;
      return next;
    }

    public Point nextMoveUp() {
      Point next = new Point(point);
      next.y--;
      return next;
    }
  }

  public static class Hero extends MItem {

    public Hero(Image img) {
      super(img);
    }
  }
  //</editor-fold>

  //<editor-fold defaultstate="collapsed" desc="getter and setter">
  public Estructura getEstructura() {
    if (estructura == null) {
      //<editor-fold defaultstate="collapsed" desc="default">
      final Estructura e = new Estructura("Ejemplo", new Dimension(4, 4));
      Estructura.Casilla inicio = new Estructura.Casilla(new Point(0, 0), new Espacio("t1", new File("ext/start.png")));
      Estructura.Casilla fin = new Estructura.Casilla(new Point(3, 2), new Espacio("t4", new File("ext/end.png")));

      Point[] walls = new Point[]{
        new Point(0, 1), new Point(0, 2),
        new Point(2, 1), new Point(2, 2),
        new Point(3, 0), new Point(3, 1)
      };
      Espacio we = new Espacio("wall", new File("ext/texture/wall.jpg"));
      we.setPasable(false);
      for (Point w : walls) {
        Estructura.Casilla wc = new Estructura.Casilla(w, we);
        e.addCasilla(wc);
      }

      e.addCasilla(inicio);
      e.addCasilla(fin);

      setEstructura(e);
      //</editor-fold>
    }
    return estructura;
  }

  public void setEstructura(Estructura estructura) {
    this.estructura = estructura;
  }

  public LinkedList<Hero> getHeroes() {
    if (heroes.isEmpty()) {
      //defaults...
      Hero h1 = new Hero(new ImageIcon("ext/character/gimnor.png").getImage());
      Hero h2 = new Hero(new ImageIcon("ext/character/lizardman.png").getImage());
      h2.point = new Point(1, 0);
      h2.keyDown = KeyEvent.VK_S;
      h2.keyLeft = KeyEvent.VK_A;
      h2.keyRight = KeyEvent.VK_D;
      h2.keyUp = KeyEvent.VK_W;
      addHero(h1);
      addHero(h2);
    }
    return heroes;
  }

  public HashMap<Integer, HashSet<Hero>> getKeyMap() {
    return keyMap;
  }
  //</editor-fold>
}
